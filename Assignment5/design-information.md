### Assignment 5：Software Design - Design Information
1. When starting the application, a user may choose to either create a new player or log in.  For simplicity in designing the application, you should consider the application to run locally; that is, only players on the same device will be able to share information (e.g., puzzles, tournaments, scores). In addition, you do not need to consider authentication or security requirements; that is, a (unique) username will be sufficient for logging in.
>To realize this requirement, the application should contain a list of items that can trigger the "create a new player" and "log in" functions. Herein, I added to the design a class “Player”, where the class contains attributes including "username" as the identifying key, "firstName", "lastName" and "email" representing the first name, last name and email for the player respectively. The "player" class would have the methods including "logIn" functionalizing the log-in function and "viewStatistics" to enable viewing-statistics function that will be explained below.

2. After logging in, the application shall allow players to (1) create a puzzle phrase, (2) solve a random puzzle, (3) create a tournament, (4) join or continue a tournament, and (5) view the puzzle statistics.
>To realize this requirement, new classes namely: "Puzzle", "tournament", "SolvePuzzle", "JoinTournament" would be necessary respectively. The "create a puzzle phrase" requirement was intrinsically satisfied by the class constructor in the "Puzzle" class. The "SolvePuzzle" class will be responsible for the "solve a random puzzle" function. The "create a tournament" requirement was intrinsically satisfied by the class constructor in the "Tournament" class. The "JoinTournament" class will be responsible for the "join or continue a tournament" requirement. Finally, I designed that "Player" can use the database, so a "viewStatistics" method that can access the database was added to the "Player" class to show user the puzzle statistics.

3. The application shall maintain an underlying database to save persistent information across runs (e.g., players, puzzles, statistics, tournament information).
> Herein, A database was added to the design. The database saves the data of the player information, player statistics, the created puzzles, the created tournaments. Importantly, the database can save persistent information and provide database search supports for methods such as "viewStatistics".

4. When creating a new player, a user will: a. Enter the player’s first name. b. Enter the player’s last name. c. Enter the player’s desired username. d. Enter the player’s email. e. Submit the information. f. Either receive a confirmation that the information is saved and return to the menu or receive an error if the username is already taken on that device and be offered the option to pick a different username. A player cannot be edited or deleted after a successful save.
> When a new "Player" class is created, the constructor method collects the player information entered in the UI text. Before assigning the identifier "username" to the new "Player" object, the method will query the database to check whether the specific username is available. An alter would be shown if the username is already taken. If the username is not yet taken, the information will be assigned to the respective attributes in the new "Player" object.

5. To create a puzzle, the player will: a. Enter a phrase. b. Enter the maximum number of allowed wrong guesses a user can make before losing the game, between 0 and 10. c. Save and view the returned unique identifier for the puzzle. The puzzle may not be further edited after this point.
> The constructor of class "Puzzle" can get the entered information from the user interface, including the puzzle phrase, the maximum number of allowed wrong guesses a user can make before losing the game. A new object of "Puzzle" is generated, and the entered information is assigned to the specific attributes. A unique identifier will be generated and output to the user interface. The puzzle information then will be sent to database.

6. When a player starts solving a puzzle, whether selected randomly or belonging to a tournament, the game will: ...
> when a player starts solving a puzzle, a new object of "SolvePuzzle" class will be created, using the date from the specific "Puzzle" object. (a) Being connected to the UI, the "puzzleShow" method controls which (set of) characters to be displayed and which (set of) characters to be blanked. The "puzzleValue", initiated to be 0, will be the recorder of the prize won. The "guessCounter", initiated to be "maxNumWrongGuess" from the "Puzzle" object, will be the recorder of the guess times left. (b) The "SolvePuzzle" class has several methods for the requirements metioned including "guessConsonant" for (i), "buyVowel" for (ii). The allowed wrong guesses on UI is shown by the "guessCounter" for (iii). Finally, the "solveThisPuzzle" method will be called if the player selects to solve the puzzle, the "prizeWon" attribute is updated by the "puzzlePrizeWon" method that calculates the prize based on the requirement. If the puzzle is solved, the "gameEnd" method will also update the database accordingly.
> Lastly, I want to mention that I added two classes "Consonant" and "Vowel" to help making the methods easier to realize.

7. If a player interrupts a puzzle (e.g., by explicitly choosing to exit the game while solving a puzzle), the game must give the player the option to continue. If the player confirms that he/she wants to exit, he/she gets a prize of $0 for that puzzle, and the game ends.
> I added an "interruptPuzzle" method in the "SolvePuzzle" class. When a puzzle is interrupted, the method "interruptPuzzle" will be called. It will alert on the UI and end the game accordingly.

8. When a player selects to solve a random puzzle, the game will not chose puzzles he/she has created or already successfully/unsuccessfully played.
> The "SolvePuzzle" class in the design can use the database. A player uses a "SolvePuzzle" object starting to solve a random puzzle, this object will query the database to randomly select a puzzle that is neither played nor created by the player. The "SolvePuzzle" object will be able to access the "Puzzle" object by returned puzzle identifier from database.

9. When a player selects a tournament for which he/she has already played some of the puzzles, the game will consider these puzzles already completed and preserve the prize the player won (including $0 for puzzles the player quit or did not successfully solve).
> In this case, the new "JoinTournament" object will go through the specific "SolvePuzzle" objects to check whether the specific puzzle is solved based on the attribute "isSolved", and that is determined by the database query. If the specific puzzle is solved, the "tournamentPrizeWon" method will calculate the prize and update "tourPrizeWon" accordingly.   

10. To create a tournament, a player will: Select 1 to 5 puzzles from a list of puzzles that they have either created or already played. Enter a name for the tournament. Either receive a confirmation that the tournament has been created and return to the menu or receive an error if the tournament name is already taken and be offered the option to pick a different name. At this point, the tournament will be available for others to join.
> To realize this requirement, a "puzzleList" is added to "Tournament" class. The "puzzleList" is a list containing the puzzle identifiers. the constructor will call "checkTourName" method to check whether the name is taken already based on database query, before it confirms on UI. Finally, the constructor also records the username for whom creates this tournament. The tournament information will be recorded in database by "tourToDatabase" method.    

11. To play a tournament, a player can select whether to join a new tournament or continue a tournament he/she has already joined...
> Based on the database query, the "JoinTournament" object contains the Boolean attribute "hasAlreadyJoined" to tell whether the player has joined the tournament and attribute "hasCompleted" to tell whether the specific tournament is completed already. By checking that, the player would be able to select to start a new tournament or continue an old one. The database query makes sure that all the returned tournaments meet the requirement in (a). Because the "JoinTournament" class can use "SolvePuzzle" class, it also would be able to use the methods in "SolvePuzzle". After all the requirements are confirmed in (a), the "JoinTournament" object will create new "SolvePuzzle" object to start solving puzzle that is described in (b). When the all the "SolvePuzzle" objects are marked "isSolved" true, the "tournamentEnd" function added will be called to function the requirement in (c).

12. When a player opts to view the puzzle statistics, the game will show four pieces of information: ...
> In this case, the player uses the "viewStatistics" method that extracts the required information from the database. As described above, several methods that belong to different classes are designed to record the information in the database. As listed below: (a) "puzzleEnd" method in "Puzzle" class records the puzzles solved by the player and the prize won on the database; (b) "tournamentEnd" method in "Tournament" class functionalizes similarly for tournaments as well; (c) and (d) embedded database query methods will provide the organized complete list of the information required, since all the classes can use the database.

13. The User Interface (UI) shall be intuitive and responsive.
> The UI is not a class, so it is not shown in the UML class diagram. The user interface will be designed accordingly. The buttons will be designed based on the requirement and connected to the classes designed. However, the UI design is not shown in the UML, as the interface is to use classes and methods, but it would not affect the class relationships.

14. The performance of the game should be such that players does not experience any considerable lag between their actions and the response of the game.
> This requirement cannot be shown realized in the UML class diagram, because performance is a result, but not a class. However, a reasonable design of the class structure and UI design would lead to good performance of the game.  
